<server on="init">
/**
* Database script migration functionality
*
* The `app.dbMigration(version, title, handler)` function specifies a migration stratergy for each database version and
* correctly bumps the version sequencially until it hits the highest stratergy version found
*
* @example Simple migration example
* <server on="migrations">
* app.dbMigration(101, 'Fix widgets', ()=>                        // Declare we are upgrading to version 101
*   db.widgets.find().cursor.eachAsync(widget => {                // Iterate over each widget (3 at a time, see later)
*     widget.status = 'newStatus';                                // Change doc in some way
*     return widget.save();                                       // Save it back
*   }, {parallel: 3})                                             // Process 3 documents at once
* )
*/

var _ = require('lodash');
var fs = require('fs');

/**
* Declare a database migration stratergy
* @param {number} version Version declaration to declare a migration from
* @param {function} handler Handler function to call when a migration is needed
*/
app.dbMigration = function(version, title, handler) {
	if (!_.isNumber(version) || !_.isString(title) || !_.isFunction(handler)) throw new Error('app.dbMigration expects (version<Number>, title<String>, handler<function>)');

	if (
		!app.config.mongo.migration // Migration is disabled
		|| app.config.mongo.version >= version  // Database is already old enough
	) return; // Ignore this migration listing

	app.dbMigration.migrations.push({version, title, handler});
};


/**
* Set the current database version
* @param {number} version The version to set the current database at
* @returns {Promise} A promise which will resolve when the version has been set
*/
app.dbMigration.setVersion = function(version) {
	return fs.promises.writeFile(`${app.config.paths.root}/.git/.doop-db-version`, version.toString())
		.then(()=> app.config.mongo.version = version)
};

/**
* Collection of migrations to apply
* @type {array<Object>}
* @property {number} version The version the migration needs applying at
* @property {string} title The description of the migration
* @property {function} handler The handler async function to call
*/
app.dbMigration.migrations = [];

// Populate app.config.mongo.version
return fs.promises.readFile(`${app.config.paths.root}/.git/.doop-db-version`, 'utf-8')
	.then(contents => app.config.mongo.version = parseFloat(contents) || 0)
	.catch(e => app.dbMigration.setVersion(0)) // Error fetching cache value - probably doesn't have one - assume '0'
</server>

<server on="preEndpoints">
/**
* Apply all migrations (if any)
*/
var _ = require('lodash');

return Promise.resolve()
	.then(()=> app.emit('migrations'))
	.then(()=> {
		if (!app.config.mongo.migration || !app.dbMigration.migrations.length) return; // Nothing to do

		var targetVersion = Math.max(...app.dbMigration.migrations.map(m => m.version));
		app.log('Applying database migration', app.log.colors.cyan(app.config.mongo.version), '->', app.log.colors.cyan(targetVersion));

		return Promise.allSeries(
			_.chain(app.dbMigration.migrations)
				.sortBy('version')
				.map(migration => ()=> {
					app.log('Applying database migration', app.log.colors.cyan(app.config.mongo.version), '=>', app.log.colors.cyan(migration.version), '-', app.log.colors.gray(migration.title));
					return Promise.resolve(migration.handler())
						.then(()=> {
							// Bump current version if everything at this level succeded
							if (migration.version > app.config.mongo.version + 1) return app.dbMigration.setVersion(migration.version);
						})
				})
				.value()
		)
		.then(()=> app.dbMigration.setVersion(targetVersion))
		.then(()=> app.log('Database migration complete to version', app.log.colors.cyan(targetVersion)))
	})
</server>
