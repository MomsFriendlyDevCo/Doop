<script lang="js" backend on="middleware">
var _ = require('lodash');
var moment = require('moment');
var timestring = require('timestring');

/**
* Middleware to return a v-chart-timeseries compatible timeseries dataset
* @param {object} options Options to use to generate the middleware
* @param {string} options.collection Collection to return the timeseries of
* @param {string} [options.field='created'] Collection field to iterate the time series by, must be a date. All non-dates are removed
* @param {string} [options.field2='status'] Secondary field to iterate through
* @param {array} [options.values] Values to return as sets from the secondary field, defaults to using the enum set of the field
* @param {function} [options.valueLabel] Function called as `(value, offset, dataSet, settings)` to rewrite a value, default is to use _.startCase()
* @param {function} [options.valueClor] Function called as `(value, offset, dataSet, settings)` to return a valid CSS color
* @param {boolean} [options.fixDates=true] Whether to preparse the field into a valid Mongo date before iterating, this fixes string date storage
* @param {function} [options.interval="1d"] Promisable function called as `(req, res, settings)` which should return the interval of the timeseries, defaults to parsing req.query.interval via timestring or '1d'
* @param {function} [options.timeLabel] Function called as `(req, res, date)` to neaten the date display, defaults to using Moment to return a simple local date
* @param {function} [options.start] Promisable function called as `(req, res, settings)` which should return the starting point of the timeseries, defaults to parsing req.query.start via moment or 1 week ago if req.query.start is unspecified
* @param {function} [options.end] Promisable function called as `(req, res, settings)` which should return the starting point of the timeseries, defaults to parsing req.query.start via moment or 1 week ago if req.query.start is unspecified
* @param {function} [options.query] Async function called as `(req, res, settings)` which can return an object further used to filter down the query data, this should match any valid aggregation $match syntax
* @param {boolean} [options.passthru=false] If falsy req.send is called with the calculated timeseries, if falsy this function populates `req.timeSeries` and passes control to the next express middleware function
* @param {object} [options.output] Aggregation $bucket output as per https://docs.mongodb.com/manual/reference/operator/aggregation/bucket/#std-label-bucket-output
*/
app.middleware.express.timeSeries = options => {
	var settings = {
		collection: undefined,
		field: 'created',
		field2: 'status',
		// FIXME: Warn when enum is undefined
		values: (req, res, settings) => _.get(app.db, [settings.collection, 'schema', 'paths', settings.field2, 'options', 'enum']),
		valueLabel: (key, offset, dataSet, settings) => _.startCase(key),
		valueBackgroundColor: (key, offset, dataSet, settings) => {
			var r = ["rgb(54, 162, 235)", "rgb(75, 192, 192)", "rgb(201, 203, 207)", "rgb(255, 159, 64)", "rgb(153, 102, 255)", "rgb(255, 99, 132)", "rgb(255, 205, 86)"][offset % 7];
			return r;
		},
		valueBorderColor: (key, offset, dataSet, settings) => {
			var r = ["rgb(54, 162, 235)", "rgb(75, 192, 192)", "rgb(201, 203, 207)", "rgb(255, 159, 64)", "rgb(153, 102, 255)", "rgb(255, 99, 132)", "rgb(255, 205, 86)"][offset % 7];
			return r;
		},
		fixDates: true,
		start: (req, res) => req.query.start ? moment(req.query.start) : moment().subtract(1, 'week'),
		end: (req, res) => req.query.end ? moment(req.query.end) : moment().endOf('day'),
		interval: (req, res) => timestring(req.query.interval || '1d', 'ms'),
		timeLabel: (req, res, date) => (req.query.timeLabel) ? moment(date).format(req.query.timeLabel) : moment(date).format('ddd Do MMM'),
		passthru: false,
		query: (req, res) => ({}),
		...options,
	};
	if (!settings.collection) throw new Error('Collection must be specified for app.middleware.express.timeseries()');

	return (req, res, next) => {
		var boundaries = [];

		return Promise.resolve()
			.then(()=> Promise.all([
				Promise.resolve(settings.start(req, res, settings)),
				Promise.resolve(settings.end(req, res, settings)),
				Promise.resolve(settings.interval(req, res, settings)),
				Promise.resolve(settings.values(req, res, settings)),
				Promise.resolve(settings.query(req, res, settings))
					.then(query => _.pickBy(query, (v, k) => v !== undefined)), // Remove duds from query
			]))
			.then(([start, end, interval, values, query]) => {
				// Work out boundry iterations. This should start at the `start` point and continue incrementing by `interval` until we hit `end`
				var iter = start;
				while (iter.isBefore(end)) {
					boundaries.push(iter.toDate());
					iter.add(interval, 'ms');
				}

				// Always add last boundry to keep Mongo / Buckets happy, we remove this at the end
				// This is to avoid fence-bost / off-by-one errors where today's stats don't get caught in the bucket collection from Mongo
				boundaries.push(iter.toDate());

				return {values, query};
			})
			.then(({values, query}) => app.db[settings.collection].aggregate([{$facet: _(values)
					.mapKeys()
					.mapValues(val => ([
						{$match: {
							[settings.field2]: val,
							...query,
						}},
						...(settings.fixDates // Optionally fix date conversion
							? [{$project: {
								[settings.field]: {$toDate: '$' + settings.field},
								[settings.field2]: 1,
								..._(settings.output)
									.mapValues(() => 1)
									.value(),
							}}]
							: []
						),
						{$bucket: {
							groupBy: '$' + settings.field,
							default: 'unparsable',
							boundaries,
							...(settings.output && Object.keys(settings.output).length > 0) ? { output: settings.output } : {},
						}},
					]))
					.value()
				},
			]))
			.then(dataSets => {
				boundaries.pop(); // Remove last, dud boundry mark
				return dataSets[0]; // Return only first matching dataset
			})
			.then(dataSets => Object.keys(dataSets).map((k, kOffset) => {
				var dataSet = dataSets[k];
				var dataSetMap = _(dataSet)
					.mapKeys('_id')
					.mapValues(d => {
						if (!settings.output) {
							return d.count;
						} else if (Object.keys(settings.output).length === 1) {
							return d[Object.keys(settings.output)[0]];
						} else if (Object.keys(settings.output).length > 1) {
							return _.pick(d, Object.keys(settings.output))
						}
					})
					.value();

				return {
					label: settings.valueLabel(k, kOffset, dataSet, settings),
					backgroundColor: settings.valueBackgroundColor(k, kOffset, dataSet, settings),
					borderColor: settings.valueBorderColor(k, kOffset, dataSet, settings),
					data: boundaries.map(b => dataSetMap[b] || 0), // Fill in blanks for the sparce dataSet Mongo gives us back
				};
			}))
			.then(datasets => ({
				labels: boundaries.map(l => settings.timeLabel(req, res, l)),
				boundaries,
				datasets,
			}))
			.then(data => {
				if (settings.passthru) {
					req.timeSeries = data;
					next();
				} else {
					res.send(data);
				}
			})
			.catch(res.sendError)
	};
};
</script>
